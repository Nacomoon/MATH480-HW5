︠f4442c43-24da-4719-a669-2422a01e4864︠
n = 4654252230393111226989449826741007006486078009450861095070222439898324342353927553909251532232407850265642079868425916328810273416481567992145162141358151
︡8a2ac0b7-46ac-4140-9953-720bd8117e5e︡
︠495ba5ab-4fe0-4154-b08a-c4181a0e04a0︠
Mod(2,n)^(n-1)
︡e1e37980-38e7-427e-9240-264c14d5fe13︡{"stdout":"1631275335353718272688521136992205307778996921510751912836784958121590177271097904110560032076219875741821572502979807785676850802289166219856576501165317\n"}︡
︠f327f0bb-3742-4106-839d-791ddcabcd19︠
Mod(3,n)^(n-1)
︡5922c4c9-40a7-4bbb-b682-2f614a747955︡{"stdout":"2161594494425964752904856580487313564075104542722661280056038369274480198996413144829684083911942462609728897377738856560218753936114732056632070912233505\n"}︡
︠a20002db-aa8a-4fd4-addf-d6cbe2bca572i︠
%hide
%md
Since neither of the two numbers above are 1, n is not prime.
︡d0d04016-907f-4b1c-8db2-3da088f2f1a5︡{"html":"<p>Since neither of the two numbers above are 1, n is not prime.</p>\n"}︡
︠b9f71488-f726-4521-ab97-fe03d04f50e1︠
x = floor(math.sqrt(n))
p = next_probable_prime(x+ 600000000000000000000000000000000000000000000000000000000000)
q = next_probable_prime(p)
(p*q)-n
︡0046c8ab-ef0e-4850-be32-f80a70af07b4︡{"stdout":"-771999569195259970200402072025487755361028868374287364543491514087858178123567673487940812170051284961931641001650793900070402739841758\n"}︡
︠11875cce-887e-44eb-813f-cdd1ad45a045︠
p = next_probable_prime(x+ 700000000000000000000000000000000000000000000000000000000000)
q = next_probable_prime(p)
(p*q)-n
︡de33b2b2-f05e-42bd-8b84-1fa222b522ce︡{"stdout":"12872416476049199275051473816669972697825141958806448765673915462726202073636407996763954515995833343736003803058377654074078536385582412\n"}︡
︠7209f16c-8ae1-48d7-99e9-2dd657b4e87bi︠
%hide
%md
I figured p and q were somehwere close to the square root of n but I was wrong. I did however find that p is close to those big numbers up there.
So I ran an algorithm that changes each digit of 6x10^59 one at a time and looks for instances in which (p*q)-n goes from negative to positive
︡95d9ac12-ffe4-441f-a3af-2b9cb4485f00︡{"html":"<p>I figured p and q were somehwere close to the square root of n but I was wrong. I did however find that p is close to those big numbers up there. <br />\nSo I ran an algorithm that changes each digit of 6x10^59 one at a time and looks for instances in which (p*q)-n goes from negative to positive</p>\n"}︡
︠c2fa2d49-7300-4891-85a3-0ba5b178c2c2︠
j = str(600000000000000000000000000000000000000000000000000000000000)
for i in range(1,len(j)):
    for h in range(10):
        num = j[:i] + str(h) + j[i+1:]
        p = next_probable_prime(x + int(num))
        q = next_probable_prime(p)
        if (p*q)-n > 0:
            j = j[:i] + str(h-1) + j[i+1:]
            break
        if h == 9:
            j = j[:i] + str(h) + j[i+1:]
︡c54ca1b5-2a92-46e3-b69b-9ed343eb4ad2︡
︠2df3ef44-392c-4e9a-a493-11534c14f38c︠
j
︡f5e18260-1cd4-4472-a57a-047496d31db5︡{"stdout":"'605657989075057029993582771391158485451142990555026262980364'\n"}︡
︠3fd1bf16-a1da-4d89-a336-3111d21da9c9︠
p = next_probable_prime(x+ int(j))
q = next_probable_prime(p)
(p*q)-n
︡00a0c5dd-1bbd-44b4-bf36-c981cfbf78d7︡{"stdout":"0\n"}︡
︠ab49334a-c300-4990-a98f-5c14909c2fd6︠
p; q
︡1f27cb29-3457-416c-a340-eccc62df2bd2︡{"stdout":"68222080226222296181917368518534332259513625527062166102114730123514248558349\n68222080226222296181917368518534332259513625527062166102114730123514248558499\n"}︡
︠3099b48b-7972-4f41-880a-e1fa85310b2d︠
